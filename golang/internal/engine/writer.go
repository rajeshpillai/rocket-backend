package engine

import (
	"fmt"
	"strings"

	"rocket-backend/internal/metadata"
	"rocket-backend/internal/store"
)

// RelationWrite represents a nested write operation for a relation.
type RelationWrite struct {
	Relation  *metadata.Relation
	WriteMode string
	Data      []map[string]any
}

// BuildInsertSQL builds a parameterized INSERT statement.
// Returns SQL, params, and the PK field name (for RETURNING).
func BuildInsertSQL(entity *metadata.Entity, fields map[string]any, dialect store.Dialect) (string, []any) {
	pb := dialect.NewParamBuilder()
	var cols []string
	var vals []string

	for _, f := range entity.Fields {
		if f.Name == entity.PrimaryKey.Field && entity.PrimaryKey.Generated {
			// For SQLite: generate UUID PK in Go since there's no gen_random_uuid()
			if dialect.UUIDDefault() == "" {
				cols = append(cols, f.Name)
				vals = append(vals, pb.Add(store.GenerateUUID()))
			}
			continue // PK generated by DB (PostgreSQL)
		}
		if f.Auto == "create" || f.Auto == "update" {
			// Auto-timestamp fields handled below
			continue
		}
		if f.Name == "deleted_at" {
			continue
		}

		val, ok := fields[f.Name]
		if !ok {
			if f.Default != nil {
				val = f.Default
			} else if !f.Required {
				continue
			} else {
				continue // validation should have caught this
			}
		}
		cols = append(cols, f.Name)
		vals = append(vals, pb.Add(val))
	}

	// Add auto-timestamp fields
	for _, f := range entity.Fields {
		if f.Auto == "create" || f.Auto == "update" {
			cols = append(cols, f.Name)
			vals = append(vals, dialect.NowExpr())
		}
	}

	sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s",
		entity.Table,
		strings.Join(cols, ", "),
		strings.Join(vals, ", "),
		entity.PrimaryKey.Field,
	)

	return sql, pb.Params()
}

// BuildUpdateSQL builds a parameterized UPDATE statement.
func BuildUpdateSQL(entity *metadata.Entity, id any, fields map[string]any, dialect store.Dialect) (string, []any) {
	pb := dialect.NewParamBuilder()
	var sets []string

	for _, f := range entity.UpdatableFields() {
		val, ok := fields[f.Name]
		if !ok {
			continue
		}
		sets = append(sets, fmt.Sprintf("%s = %s", f.Name, pb.Add(val)))
	}

	// Auto-update timestamp
	for _, f := range entity.Fields {
		if f.Auto == "update" {
			sets = append(sets, fmt.Sprintf("%s = %s", f.Name, dialect.NowExpr()))
		}
	}

	if len(sets) == 0 {
		return "", nil
	}

	where := fmt.Sprintf("%s = %s", entity.PrimaryKey.Field, pb.Add(id))
	if entity.SoftDelete {
		where += " AND deleted_at IS NULL"
	}

	sql := fmt.Sprintf("UPDATE %s SET %s WHERE %s",
		entity.Table,
		strings.Join(sets, ", "),
		where,
	)

	return sql, pb.Params()
}

// BuildSoftDeleteSQL builds a soft-delete UPDATE statement.
func BuildSoftDeleteSQL(entity *metadata.Entity, id any, dialect store.Dialect) (string, []any) {
	pb := dialect.NewParamBuilder()
	idPlaceholder := pb.Add(id)
	sql := fmt.Sprintf("UPDATE %s SET deleted_at = %s WHERE %s = %s AND deleted_at IS NULL",
		entity.Table, dialect.NowExpr(), entity.PrimaryKey.Field, idPlaceholder)
	return sql, pb.Params()
}

// BuildHardDeleteSQL builds a DELETE statement.
func BuildHardDeleteSQL(entity *metadata.Entity, id any, dialect store.Dialect) (string, []any) {
	pb := dialect.NewParamBuilder()
	idPlaceholder := pb.Add(id)
	sql := fmt.Sprintf("DELETE FROM %s WHERE %s = %s",
		entity.Table, entity.PrimaryKey.Field, idPlaceholder)
	return sql, pb.Params()
}

// ValidateFields validates incoming fields against entity metadata.
func ValidateFields(entity *metadata.Entity, fields map[string]any, isCreate bool) []ErrorDetail {
	var errs []ErrorDetail

	// Check for unknown fields
	for key := range fields {
		if !entity.HasField(key) {
			errs = append(errs, ErrorDetail{
				Field:   key,
				Rule:    "unknown",
				Message: fmt.Sprintf("Unknown field: %s", key),
			})
		}
	}

	if isCreate {
		// Check required fields
		for _, f := range entity.WritableFields() {
			if f.Required && !f.Nullable {
				val, ok := fields[f.Name]
				if !ok || val == nil || val == "" {
					errs = append(errs, ErrorDetail{
						Field:   f.Name,
						Rule:    "required",
						Message: fmt.Sprintf("%s is required", f.Name),
					})
				}
			}
		}
	}

	// Check enum constraints
	for _, f := range entity.Fields {
		if len(f.Enum) == 0 {
			continue
		}
		val, ok := fields[f.Name]
		if !ok || val == nil {
			continue
		}
		strVal := fmt.Sprintf("%v", val)
		found := false
		for _, e := range f.Enum {
			if e == strVal {
				found = true
				break
			}
		}
		if !found {
			errs = append(errs, ErrorDetail{
				Field:   f.Name,
				Rule:    "enum",
				Message: fmt.Sprintf("%s must be one of: %s", f.Name, strings.Join(f.Enum, ", ")),
			})
		}
	}

	return errs
}

// SeparateFieldsAndRelations splits a request body into entity fields and relation writes.
func SeparateFieldsAndRelations(entity *metadata.Entity, reg *metadata.Registry, body map[string]any) (map[string]any, map[string]*RelationWrite, []string) {
	fields := make(map[string]any)
	relWrites := make(map[string]*RelationWrite)
	var unknownKeys []string

	for key, val := range body {
		// Check if it's an entity field
		if entity.HasField(key) {
			fields[key] = val
			continue
		}

		// Check if it's a relation
		rel := reg.FindRelationForEntity(key, entity.Name)
		if rel != nil && rel.Source == entity.Name {
			rw, err := parseRelationWrite(rel, val)
			if err == nil {
				relWrites[key] = rw
				continue
			}
		}

		unknownKeys = append(unknownKeys, key)
	}

	return fields, relWrites, unknownKeys
}

func parseRelationWrite(rel *metadata.Relation, val any) (*RelationWrite, error) {
	m, ok := val.(map[string]any)
	if !ok {
		return nil, fmt.Errorf("relation write must be an object")
	}

	rw := &RelationWrite{
		Relation:  rel,
		WriteMode: rel.DefaultWriteMode(),
	}

	if mode, ok := m["_write_mode"].(string); ok {
		rw.WriteMode = mode
	}

	data, ok := m["data"]
	if !ok {
		return nil, fmt.Errorf("relation write must have a 'data' array")
	}

	dataSlice, ok := data.([]any)
	if !ok {
		return nil, fmt.Errorf("relation write 'data' must be an array")
	}

	for _, item := range dataSlice {
		itemMap, ok := item.(map[string]any)
		if !ok {
			return nil, fmt.Errorf("each item in relation data must be an object")
		}
		rw.Data = append(rw.Data, itemMap)
	}

	return rw, nil
}
